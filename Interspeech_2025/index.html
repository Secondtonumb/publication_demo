<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interspeech_2025_Shadowing_Annotation</title>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Mulish:ital,wght@0,200..1000;1,200..1000&family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
  <style>
    /* ---------- Global & Typography ---------- */
    body {
      font-family: 'Mulish', 'Poppins', sans-serif;
      margin: 0;
      padding: 0;
      line-height: 1.4;
      background: #f4f4f4;
    }
    .container {
      width: 90%;
      margin: auto;
      overflow: hidden;
      text-align: center;
    }
    header {
      background: #003A91;
      color: #fff;
      padding: 20px 0 5px;
      border-bottom: #77a6f7 3px solid;
    }
    header h1 {
      font-size: 24px;
      margin: 0 0 5px;
      padding: 0;
    }
    .author-line h2, .author-line p {
      display: inline;
    }
    .author-line h2 {
      font-size: 1.2em;
    }
    /* ---------- Abstract Section ---------- */
    #abstract {
      width: 90%;
      margin: 20px 0;
      padding: 5px;
      background: #fff;
      border: 1px solid #ddd;
      text-align: center;
    }
    #abstract h3 {
      margin-top: 0;
      text-align: center;
    }
    /* ---------- Display Mode Styles ---------- */
    .file-section {
        background: #f9f9f9; /* Off-white for a gentle contrast */
        margin: 20px auto;
        padding: 5px;
        border: 1px solid #ccc;
        border-radius: 5px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    .file-section h2 {
        margin: auto;
    }
    .waveform {
      position: relative;
      width: 100%;  
      height: 100px;
      background: #f2f2f2;
      border: 1px solid #ccc;
      cursor: pointer;
      margin: 0 auto 5px auto;  /* center the waveform */
    }
    .cursor {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: red;
      pointer-events: none;
    }
    .tiers-container {
      width: 100%;
      box-sizing: border-box;
    }
    .annotation-tier {
      position: relative;
      width: 100%;
      height: 50px; /* reduced height */
      margin: 5px 0;
      background: #f9f9f9;
      border: 1px solid #ddd;
      box-sizing: border-box;
    }
    .annotation-tier h3 {
      margin: 0;
      padding: 3px 5px;
      background: #eee;
      font-size: 14px; /* slightly smaller header */
    }
    .tier-content {
      position: relative;
      height: calc(100% - 25px); /* adjusted for header height */
      width: 100%;
      box-sizing: border-box;
    }
    .annotation-interval {
      position: absolute;
      top: 0;
      height: 100%;
      white-space: nowrap;
      font-size: 5px; /* reduced font size */
      line-height: 20px; /* reduced line height */
      box-sizing: border-box;
      text-align: center;
      cursor: pointer;
      overflow: hidden;
      transition: background 0.01s, border 0.01s;
    }
    .annotation-interval.active {
      border: 1px solid #333;
      background-color: #c8e6c9 !important;
    }
    .abstract-container, .abstract-table {
        width: 90%;
        margin: auto;
        overflow: hidden;
        text-align: center;
      }
      .abstract-text, .abstract-figure {
        width: 90%;
        text-align: center;
        width: 100%;
        padding: 5px;
      }
    /* ---------- Footer ---------- */
    footer {
      background: #003A91;
      color: #fff;
      text-align: center;
      padding: 5px;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <!-- Header with Title, Author, Institution -->
  <header>
    <div class="container">
      <h1>A Perception-Based L2 Speech Intelligibility Indicator: <br> Leveraging A Rater’s Shadowing and Sequence-to-Sequence Voice Conversion</h1>
      <section id="author-institution">
        <div class="author-line">
          <h2>Author: Haopeng Geng, Saito Daisuke, Nobuaki Minematsu
          </h2>
        </div>
        <div class="author-line">
          <h2>Institution: Graduate School of Engineering, The University of Tokyo</h2>
        </div>
      </section>
    </div>
  </header>

  <section id="introduction">
    <table class="abstract-table" style="width: 90%; border-collapse: collapse; border-radius: 5px; ">
        <thead>
            <tr style="background: #003A91; color: #fff;">
                <th style="width: 50%; padding: 5px; text-align: center;">
                    <h2 style="margin: 0;">Abstract</h2>
                </th>
                <th style="width: 50%; padding: 5px; text-align: center;">
                    <h2 style="margin: 0;">Research Background</h2>
                </th>
            </tr>
        </thead>
        <tbody>
            <tr style="background: #fff;">
                <td style="width: 50%; padding: 5px; border: 1px solid #ddd; vertical-align: top; text-align: left; border-radius: 5px;">
                    Evaluating L2 speech intelligibility is crucial for effective computer-assisted language learning (CALL). Conventional ASR-based methods often focus on native-likeness, which may fail to capture the actual intelligibility perceived by human listeners. In contrast, our work introduces a novel, perception-based L2 speech intelligibility indicator that leverages native rater’s shadowing data within a sequence-to-sequence (seq2seq) voice conversion framework. By integrating an alignment mechanism and acoustic feature reconstruction, our approach simulates the auditory perception of native listeners, identifying segments in L2 speech that are likely to cause comprehension difficulties. Both objective and subjective evaluations indicate that our method aligns more closely with native judgments than traditional ASR-based metrics, offering a promising new direction for CALL systems in global, multilingual contexts.
                </td>
                <td style="width: 50%; padding: 5px; border: 1px solid #ddd; vertical-align: top; text-align: center; border-radius: 5px;">
                    <img src="fig/Alignment_based_ppg.png" alt="Purposed Method 1" style="width: 100%;">
                </td>
            </tr>
        </tbody>
    </table>
</section>

  <section id="introduction">
    <table class="abstract-table" style="width: 90%; border-collapse: collapse; border-radius: 5px; ">
        <thead>
            <tr style="background: #003A91; color: #fff;">
                <th style="width: 40%; padding: 5px; text-align: center;">
                    <h2 style="margin: 0;">Purposed Method1</h2>
                </th>
                <th style="width: 60%; padding: 5px; text-align: center;">
                    <h2 style="margin: 0;">Purposed Method2</h2>
                </th>
            </tr>
        </thead>
        <tbody>
            <tr style="background: #fff;">
                <td style="width: 40%; padding: 5px; border: 1px solid #ddd; text-align: center; vertical-align: middle;         border-radius: 5px;
                ">
                    <img src="fig/Alignment_based.png" alt="Purposed Method 1" style="width: 45%;">
                </td>
                <td style="width: 60%; padding: 5px; border: 1px solid #ddd; text-align: center; vertical-align: middle;         border-radius: 5px;
                ">
                    <img src="fig/Model_D_on_source.png" alt="Purposed Method 2" style="width: 100%;">
                </td>
            </tr>
        </tbody>
    </table>
</section>  
  <!-- Instructions & Legend spanning full width -->
  <table class="abstract-table" style="width: 90%; border-collapse: collapse; border-radius: 5px; margin: 20px auto;">
    <thead>
      <tr style="background: #003A91; color: #fff;">
        <th style="padding: 5px; text-align: center;">
          <h2 style="margin:0;">Instructions & Legend</h2>
        </th>
      </tr>
    </thead>
    <tbody>
      <tr style="background: #fff;">
        <td style="padding: 5px; border: 1px solid #ddd; text-align: left; vertical-align: top;">
          <section class="instructions" style="margin-bottom: 15px;">
            <p><strong>Instructions:</strong> Click on the waveform to play/pause the audio. Highlighted intervals represent unintelligible words detected by various methods.</p>
          </section>
          <section class="legend">
            <dl>
              <dt><strong>Ground Truth:</strong></dt>
              <dd>Human annotations of unintelligible words based on 2-stage PPG-DTW annotation.</dd>
              <dt><strong>ASR:</strong></dt>
              <dd>ASR-based word errors.</dd>
              <dt><strong>Purposed Method 1 (VC Alignment Based):</strong></dt>
              <dd>Using alignment breakdowns in the VC framework to replicate rater’s perception breakdowns.</dd>
              <dt><strong>Purposed Method 2 (Multi-Task Learning):</strong></dt>
              <dd>Annotation based on Multi-Task Learning with seq2seq VC and disfluency detection.</dd>
            </dl>
          </section>
        </td>
      </tr>
    </tbody>
  </table>

  <!-- Examples spanning full width -->
  <table class="abstract-table" style="width: 90%; border-collapse: collapse; border-radius: 5px; margin: 20px auto 40px;">
    <thead>
      <tr style="background: #003A91; color: #fff;">
        <th style="padding: 5px; text-align: center;">
          <h2 style="margin:0;">Examples</h2>
        </th>
      </tr>
    </thead>
    <tbody>
      <tr style="background: #fff;">
        <td style="padding: 5px; border: 1px solid #ddd; vertical-align: top;">
          <div id="display-container"></div>
        </td>
      </tr>
    </tbody>
  </table>
  
  <footer>
    <p>© 2025 All Rights Reserved.</p>
  </footer>
  
  <!-- WaveSurfer Library -->
  <script src="https://unpkg.com/wavesurfer.js@5.2.0/dist/wavesurfer.min.js"></script>
  <script>
    /***********************
     * CONFIGURATION       *
     ***********************/
    const audioDir = "./wav/V000_R_max_valid/";
    const jsonDir = "./json/disfluency_word_level_res/";
    const idList = [
    "0700-0004",
    "0671-0003",
    "0736-0002",
    "0730-0000",
    "0738-0001",
    "0686-0001",
    "0693-0000",
    ];
    
    // Only display these methods.
    const allowedMethods = ["ground", "ASR", "att_based_D_on_src", "zs_hs_based_D_on_src"];
    
    /***********************
     * DISPLAY MODE SETUP  *
     ***********************/
    const displayContainer = document.getElementById('display-container');
    
    // Create a section for each file.
    idList.forEach(fileId => {
      // Create file section container.
      const fileSection = document.createElement('div');
      fileSection.classList.add('file-section');
      
      // File header.
      const header = document.createElement('h2');
      header.textContent = "ID: " + fileId;
      fileSection.appendChild(header);
      
      // Create waveform container.
      const waveformDiv = document.createElement('div');
      const waveformId = 'waveform_' + fileId;
      waveformDiv.id = waveformId;
      waveformDiv.classList.add('waveform');
      fileSection.appendChild(waveformDiv);
      
      // Create cursor element.
      const cursor = document.createElement('div');
      cursor.classList.add('cursor');
      waveformDiv.appendChild(cursor);
      
      // Create tiers container.
      const tiersContainer = document.createElement('div');
      tiersContainer.classList.add('tiers-container');
      fileSection.appendChild(tiersContainer);
      
      // Append the section.
      displayContainer.appendChild(fileSection);
      
      // Initialize a Wavesurfer instance for this file.
      const ws = WaveSurfer.create({
        container: '#' + waveformId,
        waveColor: '#ddd',
        progressColor: '#a0a0a0',
        height: 100,
        backend: 'WebAudio',
        responsive: true
      });
      
      // Load the audio file.
      ws.load(audioDir + fileId + ".wav");
      
      // Update the cursor and highlight active annotations.
      ws.on('audioprocess', (currentTime) => {
        const duration = ws.getDuration();
        const waveformWidth = waveformDiv.clientWidth;
        cursor.style.left = ((currentTime / duration) * waveformWidth) + 'px';
        tiersContainer.querySelectorAll('.annotation-interval').forEach(interval => {
          const start = parseFloat(interval.getAttribute('data-start'));
          const end = parseFloat(interval.getAttribute('data-end'));
          if (currentTime >= start && currentTime <= end) {
            interval.classList.add('active');
          } else {
            interval.classList.remove('active');
          }
        });
      });
      
      // Toggle play/pause on waveform click.
      waveformDiv.addEventListener('click', () => {
        ws.playPause();
      });
      
      // Load JSON annotations and populate tiers.
      fetch(jsonDir + fileId + ".json")
        .then(response => {
          if (!response.ok) {
            throw new Error("Error loading JSON for " + fileId);
          }
          return response.json();
        })
        .then(jsonData => {
          populateTiers(tiersContainer, jsonData, ws);
        })
        .catch(error => {
          console.error(error);
          tiersContainer.textContent = "Failed to load annotation data.";
        });
    });
    
    /***************************
     * POPULATE ANNOTATION TIERS *
     ***************************/
    function populateTiers(tiersContainer, jsonData, wsInstance) {
      const words = jsonData.words.sentence;
      const intervals = jsonData.words.interval;
      const totalDuration = intervals[intervals.length - 1][1];

      // Only loop over allowed methods.
      allowedMethods.forEach(method => {
        // For ground truth, use jsonData.words.disfluency_label.
        // For other methods, check if the key exists and has disfluency_label.
        let labels = [];
        if (method === "ground") {
          labels = jsonData.words.disfluency_label;
        } else if (jsonData.words[method] && jsonData.words[method].disfluency_label) {
          labels = jsonData.words[method].disfluency_label;
        } else {
          // Skip if the method is not present.
          return;
        }

        // Create tier container.
        const tierDiv = document.createElement('div');
        tierDiv.classList.add('annotation-tier');

        // Tier header.
        const header = document.createElement('h3');
        if (method === "ground") {
          header.textContent = "Ground Truth";
        } else if (method === "ASR") {
          header.textContent = "ASR";
        } else if (method === "att_based_D_on_src") {
          header.textContent = "Purposed Method 1";
        } else if (method === "zs_hs_based_D_on_src") {
          header.textContent = "Purposed Method 2";
        } else {
          header.textContent = method;
        }
        tierDiv.appendChild(header);

        // Tier content.
        const tierContent = document.createElement('div');
        tierContent.classList.add('tier-content');

        // Create one annotation interval per word.
        words.forEach((word, index) => {
          const interval = intervals[index];
          const start = interval[0];
          const end = interval[1];
          const leftPercent = (start / totalDuration) * 100;
          const widthPercent = ((end - start) / totalDuration) * 100;

          const wordDiv = document.createElement('div');
          wordDiv.classList.add('annotation-interval');
          wordDiv.textContent = word;
          wordDiv.style.left = leftPercent + '%';
          wordDiv.style.width = widthPercent + '%';
          wordDiv.setAttribute('data-start', start);
          wordDiv.setAttribute('data-end', end);

          // Style based on disfluency label.
          const label = labels[index];
          if (label === 1) {
            wordDiv.style.backgroundColor = "#FFF3E0";
            wordDiv.style.color = "#BF360C";
            wordDiv.style.fontWeight = "bold";
          } else {
            wordDiv.style.backgroundColor = "#ECEFF1";
            wordDiv.style.color = "#37474F";
          }

          // Clicking a word plays its segment.
          wordDiv.addEventListener('click', (e) => {
            e.stopPropagation();
            wsInstance.play(start, end);
          });

          tierContent.appendChild(wordDiv);
        });
        tierDiv.appendChild(tierContent);
        tiersContainer.appendChild(tierDiv);
      });
    }
  </script>
</body>
</html>